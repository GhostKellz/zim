const std = @import("std");
const builtin = @import("builtin");
const download = @import("../util/download.zig");
const zontom = @import("zontom");
const build_zon = @import("build_zon.zig");
const graph_mod = @import("graph.zig");
const git_mod = @import("../util/git.zig");

/// Dependency source types
pub const DependencySource = union(enum) {
    git: struct {
        url: []const u8,
        ref: []const u8, // branch, tag, or commit
    },
    tarball: struct {
        url: []const u8,
        hash: []const u8,
    },
    local: struct {
        path: []const u8,
    },
    registry: struct {
        name: []const u8,
        version: []const u8,
    },
};

/// Dependency metadata
pub const Dependency = struct {
    name: []const u8,
    source: DependencySource,
    hash: ?[]const u8 = null, // Content hash for verification

    pub fn deinit(self: *Dependency, allocator: std.mem.Allocator) void {
        allocator.free(self.name);
        switch (self.source) {
            .git => |git| {
                allocator.free(git.url);
                allocator.free(git.ref);
            },
            .tarball => |tar| {
                allocator.free(tar.url);
                allocator.free(tar.hash);
            },
            .local => |local| {
                allocator.free(local.path);
            },
            .registry => |reg| {
                allocator.free(reg.name);
                allocator.free(reg.version);
            },
        }
        if (self.hash) |h| allocator.free(h);
    }
};

/// Lockfile entry for reproducible builds
pub const LockfileEntry = struct {
    name: []const u8,
    version: []const u8,
    hash: []const u8,
    source: []const u8,
    dependencies: std.ArrayListUnmanaged([]const u8),

    pub fn deinit(self: *LockfileEntry, allocator: std.mem.Allocator) void {
        allocator.free(self.name);
        allocator.free(self.version);
        allocator.free(self.hash);
        allocator.free(self.source);
        for (self.dependencies.items) |dep| {
            allocator.free(dep);
        }
        self.dependencies.deinit(allocator);
    }
};

/// Lockfile for reproducible dependency resolution
pub const Lockfile = struct {
    entries: std.StringHashMapUnmanaged(LockfileEntry),
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) Lockfile {
        return Lockfile{
            .entries = .{},
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *Lockfile) void {
        var it = self.entries.iterator();
        while (it.next()) |entry| {
            var mut_entry = entry.value_ptr.*;
            mut_entry.deinit(self.allocator);
        }
        self.entries.deinit(self.allocator);
    }

    pub fn load(allocator: std.mem.Allocator, path: []const u8) !Lockfile {
        var lockfile = Lockfile.init(allocator);
        errdefer lockfile.deinit();

        // Try to open lockfile
        const file = std.fs.cwd().openFile(path, .{}) catch |err| {
            if (err == error.FileNotFound) {
                // No lockfile yet, return empty
                return lockfile;
            }
            return err;
        };
        defer file.close();

        // Read file contents
        const stat = try file.stat();
        const content = try allocator.alloc(u8, stat.size);
        defer allocator.free(content);

        var total_read: usize = 0;
        while (total_read < content.len) {
            const bytes_read = try file.read(content[total_read..]);
            if (bytes_read == 0) break;
            total_read += bytes_read;
        }

        // Parse TOML lockfile using zontom
        var table = zontom.parse(allocator, content) catch |err| {
            std.debug.print("Failed to parse lockfile: {}\n", .{err});
            return lockfile; // Return empty lockfile on parse error
        };
        defer table.deinit();

        // TODO: Extract lockfile entries from parsed TOML
        // For now, just return empty lockfile
        std.debug.print("Lockfile entry extraction not yet implemented\n", .{});

        return lockfile;
    }

    pub fn save(self: *Lockfile, path: []const u8) !void {
        const file = try std.fs.cwd().createFile(path, .{});
        defer file.close();

        // Write header
        try file.writeAll("# ZIM dependency lockfile\n");
        try file.writeAll("# This file is automatically generated. Do not edit manually.\n\n");

        // TODO: Serialize to TOML using zontom
        var it = self.entries.iterator();
        while (it.next()) |entry| {
            const line = try std.fmt.allocPrint(self.allocator, "# {s} = {s}\n", .{ entry.key_ptr.*, entry.value_ptr.version });
            defer self.allocator.free(line);
            try file.writeAll(line);
        }

        std.debug.print("✓ Lockfile saved to {s}\n", .{path});
    }
};

/// Content-addressed cache for dependencies (Babylon-inspired)
pub const DependencyCache = struct {
    allocator: std.mem.Allocator,
    cache_dir: []const u8,

    pub fn init(allocator: std.mem.Allocator, cache_dir: []const u8) !DependencyCache {
        return DependencyCache{
            .allocator = allocator,
            .cache_dir = try allocator.dupe(u8, cache_dir),
        };
    }

    pub fn deinit(self: *DependencyCache) void {
        self.allocator.free(self.cache_dir);
    }

    /// Get path to cached dependency by content hash
    pub fn getCachePath(self: *DependencyCache, hash: []const u8) ![]const u8 {
        // Use content-addressable storage: cache_dir/deps/ab/cd/abcdef123...
        const prefix = hash[0..2];
        const subdir = hash[2..4];

        return std.fs.path.join(
            self.allocator,
            &[_][]const u8{ self.cache_dir, "deps", prefix, subdir, hash },
        );
    }

    /// Check if dependency is already cached
    pub fn isCached(self: *DependencyCache, hash: []const u8) !bool {
        const cache_path = try self.getCachePath(hash);
        defer self.allocator.free(cache_path);

        var dir = std.fs.openDirAbsolute(cache_path, .{}) catch {
            return false;
        };
        dir.close();
        return true;
    }

    /// Store dependency in cache
    pub fn store(self: *DependencyCache, hash: []const u8, source_path: []const u8) !void {
        const cache_path = try self.getCachePath(hash);
        defer self.allocator.free(cache_path);

        // Create parent directories
        const parent = std.fs.path.dirname(cache_path) orelse return error.InvalidPath;
        try std.fs.makeDirAbsolute(parent);

        // Copy source to cache
        // TODO: Use more efficient copying for large directories
        try std.fs.cwd().copyFile(source_path, std.fs.openDirAbsolute(parent, .{}) catch unreachable, std.fs.path.basename(cache_path), .{});

        std.debug.print("✓ Cached dependency: {s}\n", .{hash[0..8]});
    }

    /// Retrieve dependency from cache
    pub fn retrieve(self: *DependencyCache, hash: []const u8, dest_path: []const u8) !void {
        const cache_path = try self.getCachePath(hash);
        defer self.allocator.free(cache_path);

        if (!try self.isCached(hash)) {
            return error.NotCached;
        }

        // Copy from cache to destination
        // TODO: Support symlinks for efficiency
        std.debug.print("Retrieving from cache: {s}\n", .{hash[0..8]});
        try std.fs.copyFileAbsolute(cache_path, dest_path, .{});
    }

    /// Clean cache (remove unused dependencies)
    pub fn clean(self: *DependencyCache, keep_hashes: []const []const u8) !void {
        _ = keep_hashes;
        std.debug.print("Cleaning dependency cache...\n", .{});

        const deps_dir = try std.fs.path.join(
            self.allocator,
            &[_][]const u8{ self.cache_dir, "deps" },
        );
        defer self.allocator.free(deps_dir);

        // TODO: Walk cache directory and remove entries not in keep_hashes
        std.debug.print("(Cache cleaning not yet implemented)\n", .{});
    }
};

/// Dependency manager with Babylon-inspired features
pub const DependencyManager = struct {
    allocator: std.mem.Allocator,
    cache: DependencyCache,
    lockfile: Lockfile,
    manifest_path: []const u8,
    lockfile_path: []const u8,

    pub fn init(allocator: std.mem.Allocator, cache_dir: []const u8) !DependencyManager {
        const cache = try DependencyCache.init(allocator, cache_dir);

        return DependencyManager{
            .allocator = allocator,
            .cache = cache,
            .lockfile = Lockfile.init(allocator),
            .manifest_path = try allocator.dupe(u8, "zim.toml"),
            .lockfile_path = try allocator.dupe(u8, "zim.lock"),
        };
    }

    pub fn deinit(self: *DependencyManager) void {
        self.cache.deinit();
        self.lockfile.deinit();
        self.allocator.free(self.manifest_path);
        self.allocator.free(self.lockfile_path);
    }

    /// Initialize a new project with zim.toml manifest
    pub fn initProject(self: *DependencyManager, project_name: []const u8) !void {
        std.debug.print("Initializing ZIM project: {s}\n", .{project_name});

        // Create zim.toml manifest
        const manifest_content = try std.fmt.allocPrint(
            self.allocator,
            \\# ZIM project manifest
            \\
            \\[project]
            \\name = "{s}"
            \\version = "0.1.0"
            \\zig = "0.16.0"
            \\
            \\[dependencies]
            \\# Add dependencies here
            \\# example = {{ git = "https://github.com/user/repo", ref = "main" }}
            \\# other = {{ tarball = "https://example.com/package.tar.gz", hash = "sha256:..." }}
            \\
            \\[dev-dependencies]
            \\# Development dependencies
            \\
            \\[targets]
            \\# Cross-compilation targets
            \\default = ["native"]
            \\
        ,
            .{project_name},
        );
        defer self.allocator.free(manifest_content);

        const file = try std.fs.cwd().createFile(self.manifest_path, .{});
        defer file.close();
        try file.writeAll(manifest_content);

        std.debug.print("✓ Created {s}\n", .{self.manifest_path});
    }

    /// Add a dependency to the manifest
    pub fn addDependency(self: *DependencyManager, dep: Dependency) !void {
        std.debug.print("Adding dependency: {s}\n", .{dep.name});

        // TODO: Parse existing manifest using zontom
        // TODO: Add new dependency to manifest
        // TODO: Resolve version conflicts
        // TODO: Update lockfile

        std.debug.print("(Dependency addition not yet fully implemented)\n", .{});
        std.debug.print("Please manually edit {s} to add dependencies\n", .{self.manifest_path});
    }

    /// Fetch all dependencies
    pub fn fetch(self: *DependencyManager) !void {
        std.debug.print("Fetching dependencies...\n\n", .{});

        // Load lockfile
        self.lockfile = try Lockfile.load(self.allocator, self.lockfile_path);

        // TODO: Parse manifest using zontom
        // TODO: Resolve dependency graph
        // TODO: Download missing dependencies
        // TODO: Verify hashes
        // TODO: Update lockfile

        std.debug.print("(Dependency fetching not yet fully implemented)\n", .{});
        std.debug.print("Lockfile will be written to {s}\n", .{self.lockfile_path});

        // Save lockfile
        try self.lockfile.save(self.lockfile_path);
    }

    /// Display dependency graph with beautiful ASCII tree
    pub fn graphDisplay(self: *DependencyManager) !void {
        std.debug.print("Dependency graph:\n\n", .{});

        // Load lockfile
        self.lockfile = try Lockfile.load(self.allocator, self.lockfile_path);

        if (self.lockfile.entries.count() == 0) {
            std.debug.print("  (no dependencies)\n", .{});
            std.debug.print("\nRun 'zim deps fetch' to install dependencies\n", .{});
            return;
        }

        // Build dependency tree
        // For now, show a simple flat list with stats
        var it = self.lockfile.entries.iterator();
        var count: usize = 0;
        while (it.next()) |entry| {
            std.debug.print("  {s} @ {s}\n", .{ entry.key_ptr.*, entry.value_ptr.version });
            for (entry.value_ptr.dependencies.items) |dep| {
                std.debug.print("    └── {s}\n", .{dep});
            }
            count += 1;
        }

        std.debug.print("\nTotal: {d} direct dependencies\n", .{count});
    }

    // Keep old name for compatibility
    pub const graph = graphDisplay;

    /// Verify all dependencies against lockfile
    pub fn verify(self: *DependencyManager) !void {
        std.debug.print("Verifying dependencies...\n", .{});

        // Load lockfile
        self.lockfile = try Lockfile.load(self.allocator, self.lockfile_path);

        if (self.lockfile.entries.count() == 0) {
            std.debug.print("No dependencies to verify\n", .{});
            return;
        }

        // TODO: Verify each dependency hash
        // TODO: Check for tampering
        // TODO: Validate signatures if required

        var verified: usize = 0;
        var it = self.lockfile.entries.iterator();
        while (it.next()) |entry| {
            std.debug.print("  Verifying {s}...", .{entry.key_ptr.*});

            // TODO: Actually verify
            std.debug.print(" ✓\n", .{});
            verified += 1;
        }

        std.debug.print("\n✓ Verified {d} dependencies\n", .{verified});
    }

    /// Update dependencies to latest versions
    pub fn update(self: *DependencyManager, dependency_name: ?[]const u8) !void {
        _ = self;
        if (dependency_name) |name| {
            std.debug.print("Updating dependency: {s}\n", .{name});
        } else {
            std.debug.print("Updating all dependencies...\n", .{});
        }

        // TODO: Check for updates
        // TODO: Resolve new versions
        // TODO: Update lockfile

        std.debug.print("(Dependency update not yet implemented)\n", .{});
    }

    /// Clean unused dependencies from cache
    pub fn cleanCache(self: *DependencyManager) !void {
        std.debug.print("Cleaning dependency cache...\n", .{});

        // Load lockfile to get active dependencies
        self.lockfile = try Lockfile.load(self.allocator, self.lockfile_path);

        var keep_hashes = try std.ArrayList([]const u8).initCapacity(self.allocator, 0);
        defer keep_hashes.deinit(self.allocator);

        var it = self.lockfile.entries.iterator();
        while (it.next()) |entry| {
            try keep_hashes.append(self.allocator, entry.value_ptr.hash);
        }

        try self.cache.clean(keep_hashes.items);
    }
};

test "dependency manager init" {
    const allocator = std.testing.allocator;
    var mgr = try DependencyManager.init(allocator, "/tmp/zim-test-cache");
    defer mgr.deinit();

    try std.testing.expect(mgr.lockfile.entries.count() == 0);
}

test "lockfile save and load" {
    const allocator = std.testing.allocator;
    var lockfile = Lockfile.init(allocator);
    defer lockfile.deinit();

    // TODO: Add entries and test round-trip
}

test "content-addressed cache" {
    const allocator = std.testing.allocator;
    var cache = try DependencyCache.init(allocator, "/tmp/zim-test-cache");
    defer cache.deinit();

    const test_hash = "abcdef1234567890";
    const is_cached = try cache.isCached(test_hash);
    try std.testing.expect(!is_cached);
}
